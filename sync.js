const { Client } = require('discord.js');
const db = require('./db');
require('dotenv').config();

const SUPPORT_GUILD_ID = process.env.SUPPORT_GUILD_ID;
const ROLES = {
    'ProMonthly': (process.env.ROLE_PRO_MONTHLY || '').trim(),
    'ProYearly': (process.env.ROLE_PRO_YEARLY || '').trim(),
    'ProPlusMonthly': (process.env.ROLE_PRO_PLUS_MONTHLY || '').trim(),
    'ProPlusYearly': (process.env.ROLE_PRO_PLUS_YEARLY || '').trim()
};

/**
 * Updates member roles based on the given tier.
 * @param {import('discord.js').Guild} guild 
 * @param {string} userId 
 * @param {string} tier 
 */
async function updateMemberRoles(guild, userId, tier) {
    try {
        const member = await guild.members.fetch(userId).catch(() => null);
        if (!member) {
            console.warn(`User ${userId} not found in guild ${guild.id}.`);
            return false;
        }

        const rolesToRemove = [
            ROLES['ProMonthly'], ROLES['ProYearly'],
            ROLES['ProPlusMonthly'], ROLES['ProPlusYearly']
        ].filter(id => id); // Remove empty/null strings

        let rolesToAdd = [];
        if (tier === 'Pro+' || tier === 'Trial Pro+') {
            // Favor Yearly if both might exist, but usually just one
            rolesToAdd = [ROLES['ProPlusMonthly'], ROLES['ProPlusYearly']].filter(id => id);
        } else if (tier === 'Pro' || tier === 'Trial Pro') {
            rolesToAdd = [ROLES['ProMonthly'], ROLES['ProYearly']].filter(id => id);
        }

        // To be safe, we only add the roles the user *actually* should have based on current roles if we wanted to be precise,
        // but typically we just add what corresponds to the tier.
        // Actually, if we are sync-ing TIERS, we should probably know WHICH exact role they have.
        // But for updateMemberRoles(web), let's just make sure they have at least one of the tier roles.

        await member.roles.remove(rolesToRemove);
        if (rolesToAdd.length > 0) {
            // Add the first valid role for that tier
            await member.roles.add(rolesToAdd[0]);
        }

        console.log(`Updated roles for ${member.user.tag} to ${tier}`);
        return true;
    } catch (err) {
        console.error(`Failed to update roles for ${userId}:`, err);
        return false;
    }
}

/**
 * Syncs subscriptions based on roles in the support server.
 * @param {Client} client 
 */
async function syncSubscriptions(client) {
    console.log('Starting subscription sync...');

    const guild = await client.guilds.fetch(SUPPORT_GUILD_ID).catch(console.error);
    if (!guild) {
        console.error(`Support guild ${SUPPORT_GUILD_ID} not found.`);
        return { success: false, message: 'Support guild not found.' };
    }

    // Fetch members with relevant roles only to stay lightweight
    let members;
    try {
        const roleIds = Object.values(ROLES).filter(id => id);
        if (roleIds.length === 0) {
            members = await guild.members.fetch(); // Fallback if no roles defined
        } else {
            // Fetch only users who have at least one subscription role
            members = await guild.members.fetch({ force: true });
            members = members.filter(m => roleIds.some(rId => m.roles.cache.has(rId)));
        }
        console.log(`Fetched ${members.size} subscribed members for sync.`);
    } catch (fetchError) {
        console.error('Failed to fetch members for sync:', fetchError);
        return { success: false, message: 'Failed to fetch members.', error: fetchError };
    }

    let updatedCount = 0;
    let errors = [];

    for (const [memberId, member] of members) {
        let tier = 'Free';
        if (member.roles.cache.has(ROLES['ProPlusYearly']) || member.roles.cache.has(ROLES['ProPlusMonthly'])) {
            tier = 'Pro+';
        } else if (member.roles.cache.has(ROLES['ProYearly']) || member.roles.cache.has(ROLES['ProMonthly'])) {
            tier = 'Pro';
        }

        if (tier !== 'Free') {
            try {
                const res = await db.query('SELECT guild_id, tier, is_active, cached_username FROM subscriptions WHERE user_id = $1', [memberId]);

                if (res.rows.length > 0) {
                    const userName = member.user.globalName || member.user.username;
                    for (const row of res.rows) {
                        const currentTier = String(row.tier || '');
                        // Don't downgrade Trial to regular Pro/Pro+ if it matches the intensity
                        const isMatch = (currentTier === tier) || (currentTier === `Trial ${tier}`) ||
                            (tier === 'Pro' && (currentTier === '1' || currentTier === '2')) ||
                            (tier === 'Pro+' && (currentTier === '3' || currentTier === '4'));

                        const needsNameUpdate = row.cached_username !== userName;

                        if (!isMatch || !row.is_active || needsNameUpdate) {
                            try {
                                const sId = row.guild_id;

                                await db.query(
                                    `UPDATE subscriptions SET 
                                    tier = $1,
                                    is_active = TRUE,
                                    cached_username = $2 
                                 WHERE guild_id = $3`,
                                    [tier, userName, sId]
                                ).catch((err) => {
                                    console.error(`[Sync] Update failed for ${sId}:`, err.message);
                                });
                                updatedCount++;
                            } catch (err) {
                                console.error(`[Sync] Failed to update row for user ${member.id}:`, err.message);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error(`[Sync] Error syncing user ${memberId}:`, err);
                errors.push(`Error syncing ${member.user.tag}`);
            }
        } else {
            // [Safety] We NO LONGER automatically deactivate subscriptions if role is not found.
            // This prevents accidental deactivation due to cache issues or bot permission problems.
            // If you want to handle "Unsub" logic, it should be done based on Expiry Date or explicit cancel.
        }
    }

    console.log(`Sync completed. Updated members: ${updatedCount}`);
    return { success: true, updated: updatedCount, errors };
}

module.exports = { syncSubscriptions, updateMemberRoles };

